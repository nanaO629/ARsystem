<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AR Navi</title>
  <style>
    body{margin:0; overflow:hidden;}

    #hudMsg {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 9999;
      background: #111c;
      color: #fff;
      padding: 10px 12px;
      border: 1px solid #333;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.5;
      max-width: min(60vw, 320px);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: none;
      word-break: break-word;
    }

    #hudAction{
      position: fixed;
      left: 50%;
      bottom: 110px;
      transform: translateX(-50%);
      z-index: 10000;

      background: rgba(0,0,0,0.88);
      color: #fff;
      border: 2px solid rgba(255,255,255,0.65);
      border-radius: 18px;

      padding: 14px 18px;
      font-size: 24px;
      font-weight: 900;
      line-height: 1.2;
      text-align: center;
      min-width: 240px;

      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      text-shadow: 0 2px 6px rgba(0,0,0,0.95);

      display: none;
      user-select: none;
      word-break: break-word;
    }
  </style>

  <script src="aframe.min.js"></script>
  <script src="aframe-ar.js"></script>
</head>
<body>
  <a-scene
    embedded
    renderer="colorManagement: true;"
    arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3; debugUIEnabled: false"
  >
    <a-assets timeout="15000">
      <a-asset-item id="arrowModel" src="arrow.glb"></a-asset-item>
    </a-assets>

    <!-- ★ライト追加：プリミティブ(円柱/円錐)に陰影が付いて立体感が出る -->
    <a-entity light="type: ambient; intensity: 0.85"></a-entity>
    <a-entity light="type: directional; intensity: 0.75" position="0 2 1"></a-entity>

    <a-entity camera></a-entity>
  </a-scene>

  <div id="hudMsg" aria-live="polite"></div>
  <div id="hudAction" aria-live="polite"></div>

  <script>
    /********************
     * 定数
     ********************/
    // 3x3バーコードは基本 0〜63 まで
    const MAX_MARKER = 63;

    /********************
     * GLB表示パラメータ
     ********************/
    const ARROW_TARGET_H   = 0.45;
    const ARROW_YAW_OFFSET = -90;

    /********************
     * 直進(cone/cylinder)の見た目
     ********************/
    // ★GLBの青っぽい色
    const FORWARD_COLOR = "#1E62FF";

    // ★サイズ（でかすぎて「おたま」になるのを防ぐため小さめ）
    const F_CYL_H = 0.75;
    const F_CYL_R = 0.06;
    const F_CONE_H = 0.28;
    const F_CONE_R = 0.12;

    // ★位置（下に見えないように中央寄り）
    const FORWARD_POS = { x: 0.00, y: 0.12, z: 0.80 };

    // ★正面から円盤に見えないように “少しだけ横に振る”
    const FORWARD_VIS_YAW = 22;  // 上下じゃなく左右なので誤解が少ない

    /********************
     * 位置（GLB用）
     ********************/
    const POS_MAP = {
      back:    { x:  0.00, y: 0.00, z: 0.65 },
      right:   { x:  0.35, y: 0.00, z: 0.75 },
      left:    { x: -0.35, y: 0.00, z: 0.75 },
      right45: { x:  0.25, y: 0.00, z: 0.95 },
      left45:  { x: -0.25, y: 0.00, z: 0.95 }
    };
    const POS_DEFAULT = { x: 0.00, y: 0.00, z: 0.75 };

    /********************
     * GLBの自動スケール
     ********************/
    AFRAME.registerComponent('fit-model-height', {
      schema: { target: { type: 'number', default: 0.6 } },
      init() {
        this.el.addEventListener('model-loaded', () => {
          const obj = this.el.getObject3D('mesh');
          if (!obj) return;
          obj.updateMatrixWorld(true);
          const box = new THREE.Box3().setFromObject(obj);
          const size = new THREE.Vector3(); box.getSize(size);
          const h = size.y || 1;
          const s = this.data.target / h;
          this.el.setAttribute('scale', `${s} ${s} ${s}`);
        });
      }
    });

    /********************
     * 方向の正規化
     ********************/
    const CANON = {
      '直進':'forward',
      '直進逆':'forwardRev',  // ★追加：マーカー側向き
      'うしろ':'back', '下':'back', 'down':'back', 'back':'back',
      '右':'right', 'right':'right',
      '左':'left',  'left':'left',
      '右斜め':'right45',
      '左斜め':'left45'
    };
    function normDir(d){ return CANON[d] || d; }

    /********************
     * GLB用 yaw
     ********************/
    const yawMap = {
      back:    180,
      right:   90,
      left:   -90,
      right45: 45,
      left45: -45
    };

    /********************
     * 範囲展開ヘルパー + ビルダー
     ********************/
    function expandKeys(keys) {
      if (Array.isArray(keys)) return keys.flatMap(k => expandKeys(k));
      if (typeof keys === 'number') return [keys];
      return String(keys).split(',').flatMap(part => {
        const s = part.trim();
        if (/^\d+-\d+$/.test(s)) {
          const [a,b] = s.split('-').map(Number);
          const lo = Math.min(a,b), hi = Math.max(a,b);
          return Array.from({length: hi-lo+1}, (_,i) => lo+i);
        }
        return [Number(s)];
      });
    }

    function buildPlan(spec) {
      const out = {};
      for (const [room, entries] of Object.entries(spec)) {
        const table = out[room] = {};
        for (const [keys, dir] of entries) {
          for (const v of expandKeys(keys)) table[v] = dir;
        }
      }
      return out;
    }

    /********************
     * plan（あなたのをそのまま入れてOK）
     ********************/
    const plan = buildPlan({
      '3': [
        [1,'右'], [2,'到着'], [3,'到着'],
        ['4-7','左'], [10,'左斜め'], ['8-9','左'],
        [10,'左'], ['11-19','左']
      ],
      '4': [
        [1,'右'], ['2-3','右'], [18,'到着'], [4,'直進'],
        ['6-9','左'], [10,'左斜め'], ['11-17','左'], [19,'左']
      ],
      '5': [
        [1,'右'], ['2-3','右'], [4,'右斜め'], [5,'直進'], [19,'到着'],
        [10,'左斜め'], ['11-17','左'], ['6-9','左']
      ],
      '6': [
        [1,'右'], ['2-3','右'], [6,'下'], ['4-5','右'], ['18-19','右'],
        ['8-9','左'], [7,'到着'], [10,'左斜め'], ['11-17','左']
      ],
      '7': [
        ['18-19','右'], [9,'下'], ['2-7','右'], [8,'到着'],
        [10,'左斜め'], ['11-17','左'], [1,'右']
      ],
      '8': [
        ['18-19','右'], [9,'到着'], ['1-6','右'], ['7-8','直進'],
        [10,'左斜め'], ['11-17','左']
      ],
      '9': [
        [1,'右'],['2-3','直進'],[4,'右'],
        ['5-6','階段上'], [18,'左'], ['11-17','左'], [23,'到着'],[19,'左'],
        [9,'左'], [7,'直進'], [10,'左斜め'], [8,'左'], ['21-22','右'], ['25-27','左'],[20,'左'],[24,'直進']
      ],
      '10': [
        ['5-6','階段上'], ['8-9','左'], [10,'左斜め'], [7,'うしろ'],[2,'直進'],[3,'逆直進'],
        ['11-17','左'], ['22-24','右'], [20,'下'], ['25-27','左'], [21,'到着']
      ],
      '11': [
        [1,'右'], ['5-6','階段上'], ['8-9','左'], [6,'階段上'], ['20-22','右'],[23,'直進'] ,['25-27','左'],
        ['11-17','左'], [10,'左斜め'], [24,'到着'],[7,'直進'],[18,'左'],[19,'左'],[4,'右'],['2-3','直進'],
      ],
      'gakumu': [],
      'free': []
    });

    const room = new URLSearchParams(location.search).get('room') || '3';

    const hudMsg = document.getElementById('hudMsg');
    const hudAction = document.getElementById('hudAction');

    /********************
     * distRaw（あなたのをそのまま入れてOK）
     ********************/
    const distRaw = {
      '3': { 1: 11, 2: 0, 3: 0 },
      '4': { 1: 20, 18: 0 },
      '5': { 1: 27, 19: 0 },
      '6': { 7: 0 },
      '7': { 8: 0 },
      '8': { 9: 0 },
      '9': { 23: 0 },
      '10': { 21: 0 },
      '11': { 24: 0 },
      'gakumu': {},
      'free': {}
    };

    function pickMsg(room, value) {
      const table = distRaw[room];
      if (!table) return null;
      const d = table[value];
      if (d == null) return null;
      if (d === 0) return "到着しました";
      return `あと${d}m`;
    }

    function updateMsgHUD(room, value) {
      const text = pickMsg(room, value);
      if (!text) {
        hudMsg.style.display = 'none';
        hudMsg.textContent = '';
        return;
      }
      hudMsg.textContent = text;
      hudMsg.style.display = 'block';
    }

    function pickAction(room, value) {
      const dir = (plan[room] || {})[value];
      if (!dir) return null;
      if (dir === '階段上' || dir === '階段') return '階段を上がってください';
      if (dir === '階段下') return '階段を下りてください';
      if (dir === '到着') return '到着しました';
      return null;
    }

    function updateActionHUD(room, value) {
      const text = pickAction(room, value);
      if (!text) return;

      hudMsg.style.display = 'none';
      hudMsg.textContent = '';

      hudAction.textContent = text;
      hudAction.style.display = 'block';
    }

    function purgeMarkerKeep(markerEl, keepId) {
      const kids = Array.from(markerEl.children);
      for (const child of kids) {
        if (child.id !== keepId) markerEl.removeChild(child);
      }
    }

    let activeActionMarker = null;
    let actionHideTimer = null;

    /********************
     * マーカー生成
     ********************/
    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', () => {
      for (let v = 0; v <= MAX_MARKER; v++) {
        const marker = document.createElement('a-marker');
        marker.setAttribute('type', 'barcode');
        marker.setAttribute('value', String(v));
        marker.setAttribute('id', `m${v}`);

        const wrap = document.createElement('a-entity');
        wrap.setAttribute('id', `wrap-${v}`);

        // ========= GLBグループ =========
        const glbGroup = document.createElement('a-entity');
        glbGroup.setAttribute('id', `glbGroup-${v}`);

        const glbYaw = document.createElement('a-entity');
        glbYaw.setAttribute('id', `glbYaw-${v}`);

        const glb = document.createElement('a-entity');
        glb.setAttribute('gltf-model', '#arrowModel');
        glb.setAttribute('fit-model-height', `target: ${ARROW_TARGET_H}`);

        glbYaw.appendChild(glb);
        glbGroup.appendChild(glbYaw);

        // ======== 直進プリミティブグループ ========
        const fGroup = document.createElement('a-entity');
        fGroup.setAttribute('id', `fGroup-${v}`);

        // ★軸（ここだけ回す）
        const fAxis = document.createElement('a-entity');
        fAxis.setAttribute('id', `fAxis-${v}`);

        // マテリアル
        const mat = `color:${FORWARD_COLOR}; metalness:0.18; roughness:0.35`;

        const cyl = document.createElement('a-cylinder');
        cyl.setAttribute('id', `fCyl-${v}`);
        cyl.setAttribute('radius', String(F_CYL_R));
        cyl.setAttribute('height', String(F_CYL_H));
        cyl.setAttribute('material', mat);
        // ★Y方向に積む（軸が回るのでこっちは固定でOK）
        cyl.setAttribute('position', `0 ${F_CYL_H/2} 0`);

        const cone = document.createElement('a-cone');
        cone.setAttribute('id', `fCone-${v}`);
        cone.setAttribute('radius-bottom', String(F_CONE_R));
        cone.setAttribute('radius-top', "0.001");
        cone.setAttribute('height', String(F_CONE_H));
        cone.setAttribute('material', mat);
        cone.setAttribute('position', `0 ${F_CYL_H + F_CONE_H/2} 0`);

        fAxis.appendChild(cyl);
        fAxis.appendChild(cone);
        fGroup.appendChild(fAxis);

        wrap.appendChild(glbGroup);
        wrap.appendChild(fGroup);
        marker.appendChild(wrap);
        scene.appendChild(marker);

        marker.addEventListener('markerFound', () => {
          purgeMarkerKeep(marker, `wrap-${v}`);

          if (actionHideTimer) { clearTimeout(actionHideTimer); actionHideTimer = null; }

          apply(v);
          updateMsgHUD(room, v);

          const a = pickAction(room, v);
          if (a) {
            updateActionHUD(room, v);
            activeActionMarker = v;
          } else {
            hudAction.style.display = 'none';
            hudAction.textContent = '';
            activeActionMarker = null;
          }
        });

        marker.addEventListener('markerLost', () => {
          if (activeActionMarker !== v) return;

          if (actionHideTimer) clearTimeout(actionHideTimer);
          actionHideTimer = setTimeout(() => {
            hudAction.style.display = 'none';
            hudAction.textContent = '';
            activeActionMarker = null;
            actionHideTimer = null;
          }, 600);
        });
      }

      apply();
    });

    /********************
     * 表示適用
     ********************/
    function apply(foundValue) {
      const table = plan[room] || {};
      const from = (foundValue != null ? foundValue : 0);
      const to   = (foundValue != null ? foundValue : MAX_MARKER);

      for (let v = from; v <= to; v++) {
        const dir = table[v];

        const wrap     = document.getElementById(`wrap-${v}`);
        const glbGroup = document.getElementById(`glbGroup-${v}`);
        const glbYaw   = document.getElementById(`glbYaw-${v}`);
        const fGroup   = document.getElementById(`fGroup-${v}`);
        const fAxis    = document.getElementById(`fAxis-${v}`);

        if (!wrap || !glbGroup || !glbYaw || !fGroup || !fAxis) continue;

        // 初期化
        wrap.setAttribute('visible', false);
        glbGroup.setAttribute('visible', false);
        fGroup.setAttribute('visible', false);

        wrap.setAttribute('position', `${POS_DEFAULT.x} ${POS_DEFAULT.y} ${POS_DEFAULT.z}`);
        glbYaw.setAttribute('rotation', '0 0 0');
        fGroup.setAttribute('rotation', `0 0 0`);
        fAxis.setAttribute('rotation', `0 0 0`);

        if (!dir) continue;

        if (dir === '階段' || dir === '階段上' || dir === '階段下' || dir === '到着') {
          continue;
        }

        const key = normDir(dir);

        wrap.setAttribute('visible', true);

        // 位置
        if (key === 'forward' || key === 'forwardRev') {
          wrap.setAttribute('position', `${FORWARD_POS.x} ${FORWARD_POS.y} ${FORWARD_POS.z}`);
        } else {
          const p = POS_MAP[key] || POS_DEFAULT;
          wrap.setAttribute('position', `${p.x} ${p.y} ${p.z}`);
        }

        // ========= 直進 =========
        if (key === 'forward' || key === 'forwardRev') {
          fGroup.setAttribute('visible', true);
          glbGroup.setAttribute('visible', false);

          // ★正面円盤化を防ぐ：少しだけ横に向ける
          // （上/下ではないので「下矢印？」になりにくい）
          const yaw = (key === 'forward') ? FORWARD_VIS_YAW : -FORWARD_VIS_YAW;
          fGroup.setAttribute('rotation', `0 ${yaw} 0`);

          // ★ここが本命：
          // forward（自分側）→ 軸を「-Z」方向に倒す
          // forwardRev（マーカー側）→ 軸を「+Z」方向に倒す
          //
          // もしあなたの環境で「逆」だったら、ここの ± を入れ替えるだけでOK
          if (key === 'forward') {
            fAxis.setAttribute('rotation', `-90 0 0`);
          } else {
            fAxis.setAttribute('rotation', `90 0 0`);
          }

          continue;
        }

        // ========= それ以外はGLB =========
        fGroup.setAttribute('visible', false);
        glbGroup.setAttribute('visible', true);

        const baseYaw = yawMap[key];
        if (typeof baseYaw === 'number') {
          const yaw = ((baseYaw + ARROW_YAW_OFFSET) % 360 + 360) % 360;
          glbYaw.setAttribute('rotation', `0 ${yaw} 0`);
        } else {
          wrap.setAttribute('visible', false);
        }
      }
    }
  </script>
</body>
</html>
