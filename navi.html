<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AR Navi</title>
  <style>
    body{margin:0; overflow:hidden;}
    /* ▼ 右下メッセージHUD */
    #hudMsg {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 9999;
      background: #111c;
      color: #fff;
      padding: 10px 12px;
      border: 1px solid #333;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.5;
      max-width: min(60vw, 320px);
      backdrop-filter: blur(6px);
      display: none; /* 初期は非表示 */
      word-break: break-word;
    }
  </style>
  <script src="aframe.min.js"></script>
  <script src="aframe-ar.js"></script>
</head>
<body>
  <!-- ===== A-Frame / AR.js シーン ===== -->
  <a-scene
    embedded
    renderer="colorManagement: true;"
    arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3; debugUIEnabled: false"
  >
    <!-- 3Dアセットを先読み -->
    <a-assets timeout="15000">
      <a-asset-item id="arrowModel"      src="arrow.glb"></a-asset-item>
      <a-asset-item id="upStairsModel"   src="up stairs.glb"></a-asset-item>
      <a-asset-item id="downStairsModel" src="down stairs.glb"></a-asset-item>
      <a-asset-item id="arrivalModel"    src="arrival.glb"></a-asset-item>
    </a-assets>

    <!-- カメラ -->
    <a-entity camera></a-entity>
  </a-scene>

  <!-- ▼ 右下メッセージHUD -->
  <div id="hudMsg" aria-live="polite"></div>

  <script>
    /********************
     * 定数
     ********************/
    const MAX_MARKER = 58;

    /********************
     * 表示パラメータ
     ********************/
    const ARROW_TARGET_H   = 0.45; // 矢印の見かけ高さ(m)
    const STAIRS_TARGET_H  = 0.60; // 階段の見かけ高さ(m)
    const ARRIVAL_TARGET_H = 0.60; // 到着表示の見かけ高さ(m)
    const ARROW_YAW_OFFSET = -90;  // 矢印GLBの前向き補正（モデルに合わせて調整）
    const STAIRS_GROUP_POS = { x:0, y:0.8, z:0 }; // 階段看板の位置
    const ARRIVAL_GROUP_POS= { x:0, y:0.8, z:0 }; // 到着看板の位置

    /********************
     * 自作コンポーネント
     ********************/
    // GLBの全高を指定値に合わせる（モデルのバウンディングから自動スケール）
    AFRAME.registerComponent('fit-model-height', {
      schema: { target: { type: 'number', default: 0.6 } },
      init() {
        this.el.addEventListener('model-loaded', () => {
          const obj = this.el.getObject3D('mesh');
          if (!obj) return;
          obj.updateMatrixWorld(true);
          const box = new THREE.Box3().setFromObject(obj);
          const size = new THREE.Vector3(); box.getSize(size);
          const h = size.y || 1;
          const s = this.data.target / h;
          this.el.setAttribute('scale', `${s} ${s} ${s}`);
        });
      }
    });

    // 看板のようにY軸だけカメラへ正対させる（上下の傾きは追従しない）
    AFRAME.registerComponent('face-camera-yaw', {
      tick() {
        const cam = this.el.sceneEl && this.el.sceneEl.camera;
        if (!cam) return;
        const pos = new THREE.Vector3();
        this.el.object3D.getWorldPosition(pos);
        const dx = cam.position.x - pos.x;
        const dz = cam.position.z - pos.z;
        const yaw = Math.atan2(dx, dz) * 180 / Math.PI;
        this.el.setAttribute('rotation', `0 ${yaw} 0`);
      }
    });

    /********************
     * 方向の正規化 + 矢印角度
     ********************/
    const CANON = {
      '直進':'forward', 'up':'forward',
      'うしろ':'back', '下':'back', 'down':'back', 'back':'back',
      '右':'right', 'right':'right',
      '左':'left',  'left':'left',
      '右斜め':'right45',
      '左斜め':'left45'
    };
    function normDir(d){ return CANON[d] || d; }

    const yawMap = {
      forward: 0,
      back:    180,
      right:   90,
      left:   -90,
      right45: 45,
      left45: -45
    };

    /********************
     * 範囲展開ヘルパー + ビルダー
     ********************/
    function expandKeys(keys) {
      if (Array.isArray(keys)) return keys.flatMap(k => expandKeys(k));
      if (typeof keys === 'number') return [keys];
      return String(keys).split(',').flatMap(part => {
        const s = part.trim();
        if (/^\d+-\d+$/.test(s)) {
          const [a,b] = s.split('-').map(Number);
          const lo = Math.min(a,b), hi = Math.max(a,b);
          return Array.from({length: hi-lo+1}, (_,i) => lo+i);
        }
        return [Number(s)];
      });
    }

    function buildPlan(spec) {
      const out = {};
      for (const [room, entries] of Object.entries(spec)) {
        const table = out[room] = {};
        for (const [keys, dir] of entries) {
          for (const v of expandKeys(keys)) table[v] = dir;
        }
      }
      return out;
    }

    /********************
     * 経路テーブル（あなたの入力を修正反映）
     ********************/
    const plan = buildPlan({
      '3': [
        [1,'右'], [2,'到着'], [3,'到着'],
        ['4-7','左'], [10,'左斜め'], ['8-9','左'],
        [10,'左'], ['11-19','左']
      ],
      '4': [
        [1,'右'], ['2-3','右'], [18,'到着'], [4,'直進'],
        ['6-9','左'], [10,'左斜め'], ['11-17','左'], [19,'左']
      ],
      '5': [
        [1,'右'], ['2-3','右'], [4,'右斜め'], [5,'直進'], [19,'到着'],
        [10,'左斜め'], ['11-17','左'], ['6-9','左']
      ],
      '6': [
        [1,'右'], ['2-3','右'], [6,'下'], ['4-5','右'], ['18-19','右'],
        ['8-9','左'], [7,'到着'], [10,'左斜め'], ['11-17','左']
      ],
      '7': [
        ['18-19','右'], [9,'下'], ['2-7','右'], [8,'到着'],
        [10,'左斜め'], ['11-17','左'], [1,'右']
      ],
      '8': [
        ['18-19','右'], [9,'到着'], ['1-6','右'], ['7-8','直進'],
        [10,'左斜め'], ['11-17','左']
      ],
      '9': [
        ['1-4','右'],
        ['5-6','階段上'], [18,'右'], ['12-17','左'], [23,'到着'],
        [9,'左'], [7,'直進'], [10,'左斜め'], [8,'右'], ['20-22','左'], ['25-27','左']
      ],
      '10': [
        ['1-4','右'], ['5-6','階段上'], ['8-9','左'], [10,'左斜め'], [7,'直進'],
        ['11-17','左'], ['22-24','右'], [20,'下'], ['25-27','左'], [21,'到着']
      ],
      '11': [
        ['1-4','右'], ['5-6','階段上'], [8,'左'], [6,'階段上'], ['20-23','左'], ['25-27','左'],
        ['11-17','左'], [10,'左斜め'], [24,'到着']
      ],
      'gakumu': [
        ['1-4','右'], ['5-6','階段上'], [8,'左'], [6,'階段上'], ['20-26','右'], [27,'下'],
        ['11-17','左'], [10,'左斜め'], [28,'到着']
      ]
    });

    /********************
     * room の決定
     ********************/
    const room = new URLSearchParams(location.search).get('room') || '3';

    /********************
     * マーカーの生成（1..MAX_MARKER）
     ********************/
    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', () => {
      for (let v = 1; v <= MAX_MARKER; v++) {
        const marker = document.createElement('a-marker');
        marker.setAttribute('type', 'barcode');
        marker.setAttribute('value', String(v));
        marker.setAttribute('id', `m${v}`);

        // --- 矢印ノード ---
        const arrowWrap = document.createElement('a-entity');
        arrowWrap.setAttribute('id', `arrowWrap-${v}`);
        const arrowYaw = document.createElement('a-entity');
        arrowYaw.setAttribute('id', `arrowYaw-${v}`);
        const arrow = document.createElement('a-entity');
        arrow.setAttribute('gltf-model', '#arrowModel');
        arrow.setAttribute('fit-model-height', `target: ${ARROW_TARGET_H}`);
        arrowYaw.appendChild(arrow);
        arrowWrap.appendChild(arrowYaw);

        // --- 階段ノード（UP/DOWN） ---
        const stairsGroup = document.createElement('a-entity');
        stairsGroup.setAttribute('id', `stairsGroup-${v}`);
        stairsGroup.setAttribute('position', `${STAIRS_GROUP_POS.x} ${STAIRS_GROUP_POS.y} ${STAIRS_GROUP_POS.z}`);
        const stairsUp = document.createElement('a-entity');
        stairsUp.setAttribute('id', `stairsUp-${v}`);
        stairsUp.setAttribute('gltf-model', '#upStairsModel');
        stairsUp.setAttribute('fit-model-height', `target: ${STAIRS_TARGET_H}`);
        stairsUp.setAttribute('face-camera-yaw', '');
        const stairsDown = document.createElement('a-entity');
        stairsDown.setAttribute('id', `stairsDown-${v}`);
        stairsDown.setAttribute('gltf-model', '#downStairsModel');
        stairsDown.setAttribute('fit-model-height', `target: ${STAIRS_TARGET_H}`);
        stairsDown.setAttribute('face-camera-yaw', '');
        stairsGroup.appendChild(stairsUp);
        stairsGroup.appendChild(stairsDown);

        // --- 到着ノード ---
        const arrivalGroup = document.createElement('a-entity');
        arrivalGroup.setAttribute('id', `arrivalGroup-${v}`);
        arrivalGroup.setAttribute('position', `${ARRIVAL_GROUP_POS.x} ${ARRIVAL_GROUP_POS.y} ${ARRIVAL_GROUP_POS.z}`);
        arrivalGroup.setAttribute('face-camera-yaw', '');
        const arrival = document.createElement('a-entity');
        arrival.setAttribute('id', `arrival-${v}`);
        arrival.setAttribute('gltf-model', '#arrivalModel');
        arrival.setAttribute('fit-model-height', `target: ${ARRIVAL_TARGET_H}`);
        arrivalGroup.appendChild(arrival);

        // マーカーにぶら下げる
        marker.appendChild(arrowWrap);
        marker.appendChild(stairsGroup);
        marker.appendChild(arrivalGroup);
        scene.appendChild(marker);

        // 検出イベント：表示適用＋メッセージ更新
        marker.addEventListener('markerFound', () => {
          apply(v);
          updateMsgHUD(room, v);
        });
      }
      // 初期反映
      apply();
    });

    /********************
     * 表示適用
     ********************/
    function apply(foundValue) {
      const table = plan[room] || {};
      const loopFrom = (foundValue ? foundValue : 1);
      const loopTo   = (foundValue ? foundValue : MAX_MARKER);

      for (let v = loopFrom; v <= loopTo; v++) {
        const dir = table[v];

        const arrowWrap   = document.getElementById(`arrowWrap-${v}`);
        const arrowYaw    = document.getElementById(`arrowYaw-${v}`);
        const stairsGroup = document.getElementById(`stairsGroup-${v}`);
        const stairsUp    = document.getElementById(`stairsUp-${v}`);
        const stairsDown  = document.getElementById(`stairsDown-${v}`);
        const arrivalGroup= document.getElementById(`arrivalGroup-${v}`);

        // いったん全部非表示
        if (arrowWrap)    arrowWrap.setAttribute('visible', false);
        if (stairsGroup)  stairsGroup.setAttribute('visible', false);
        if (stairsUp)     stairsUp.setAttribute('visible', false);
        if (stairsDown)   stairsDown.setAttribute('visible', false);
        if (arrivalGroup) arrivalGroup.setAttribute('visible', false);

        if (!dir) continue;

        // 階段
        if (dir === '階段' || dir === '階段上' || dir === '階段下') {
          stairsGroup.setAttribute('visible', true);
          if (dir === '階段下') stairsDown.setAttribute('visible', true);
          else stairsUp.setAttribute('visible', true); // '階段' は上り扱い
          continue;
        }

        // 到着
        if (dir === '到着') {
          arrivalGroup.setAttribute('visible', true);
          const hud = document.getElementById('hudMsg');
          if (hud) { hud.style.display = 'none'; hud.textContent = ''; }
          continue;
        }

        // 矢印（回転）
        const baseYaw = yawMap[normDir(dir)];
        if (typeof baseYaw === 'number') {
          const yaw = ((baseYaw + ARROW_YAW_OFFSET) % 360 + 360) % 360;
          arrowWrap.setAttribute('visible', true);
          arrowYaw.setAttribute('rotation', `0 ${yaw} 0`);
        }
      }
    }

    /********************
     * メッセージ（任意）
     ********************/
    const MSG_HINT = {
      default: { },
      '3':  { 1:{msg:"あと m"}, 4:{msg:"あと10m"}, },
      '4':  { 5:{msg:"左に進むと次のマーカーで到着"} },
      '5':  { 6:{msg:"左に進むと次のマーカーで到着"} },
      '6':  { 9:{msg:"左に進むと次のマーカーで到着"} },
      '7':  { 8:{msg:"左に進むと次のマーカーで到着"} },
      '8':  { 6:{msg:"右に進むと次のマーカーで到着"}, 8:{msg:"反対側が目的地です"} },
      '9':  { 16:{msg:"もうすぐ目的地です"} },
      '10': { 14:{msg:"左に進むと次のマーカーで到着"}, 12:{msg:"左に進むと2個先のマーカーで到着"}, 16:{msg:"右に進むと次のマーカーで到着"} },
      '11': { 17:{msg:"反対側が目的地です"} }
    };

    const hudMsg = document.getElementById('hudMsg');

    function pickMsg(room, value){
      if (MSG_HINT[room] && MSG_HINT[room][value]) return MSG_HINT[room][value].msg;
      if (MSG_HINT.default && MSG_HINT.default[value]) return MSG_HINT.default[value].msg;
      return null;
    }

    function updateMsgHUD(room, value){
      const text = pickMsg(room, value);
      if (!text) {
        hudMsg.style.display = 'none';
        hudMsg.textContent = '';
        return;
      }
      hudMsg.textContent = text;
      hudMsg.style.display = 'block';
    }
  </script>
</body>
</html>
